<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='HTTP'>/**
</span> * @class  	HTTP
 * @author  Flavio De Stefano &lt;flavio.destefano@caffeinalab.com&gt;
 */


<span id='HTTP-property-config'>/**
</span> * @property config
 * @property {String}  config.base The base URL of the API
 * @property {Number}  [config.timeout=10000] Global timeout for the reques. after this value (express in milliseconds) the requests throw an error.
 * @property {Object}  [config.headers={}] Global headers for all requests.
 * @property {Object}  [config.useCache=true] Global cache flag.
 * @property {Boolean} [config.errorAlert=true] Global error alert handling.
 * @property {Boolean} [config.log=false]
 * @property {Boolean} [config.logResponse=false]
 * @property {Boolean} [config.bypassExpireWhenOffline=true] Bypass the check of expiration cache when Internet is offline.
 */
exports.config = _.extend({
	base: &#39;&#39;,
	timeout: 10000,
	errorAlert: true,
	headers: {},
	useCache: true,
	log: false,
	logResponse: false,
	bypassExpireWhenOffline: true
}, Alloy.CFG.T ? Alloy.CFG.T.http : {});

var Event = require(&#39;T/event&#39;);

<span id='HTTP-method-event'>/**
</span> * @method event
 */
exports.event = function(name, cb) {
	Event.on(&#39;http.&#39;+name, cb);
};

<span id='HTTP-method-getUniqueId'>/**
</span> * @method getUniqueId
 * @return {String}
 */
var __uniqueId = 0;
exports.getUniqueId = function() {
	return __uniqueId++;
};

var headers = _.clone(exports.config.headers);

<span id='HTTP-method-getHeaders'>/**
</span> * @method getHeaders
 * @return {Object}
 */
exports.getHeaders = function() {
	return headers;
};

<span id='HTTP-method-addHeader'>/**
</span> * @method addHeader
 * Add a global header for all requests
 * @param {String} key 		The header key
 * @param {String} value 	The header value
 */
exports.addHeader = function(key, value) {
	headers[key] = value;
};

<span id='HTTP-method-removeHeader'>/**
</span> * @method removeHeader
 * Remove a global header
 * @param {String} key 		The header key
 */
exports.removeHeader = function(key) {
	delete headers[key];
};

<span id='HTTP-method-resetHeaders'>/**
</span> * @method resetHeaders
 * Reset all globals headers
 */
exports.resetHeaders = function() {
	headers = {};
};


var queue = [];

<span id='HTTP-method-isQueueEmpty'>/**
</span> * @method isQueueEmpty
 * Check if the requests queue is empty
 * @return {Boolean}
 */
exports.isQueueEmpty = function(){
	return _.isEmpty(queue);
};

<span id='HTTP-method-getQueue'>/**
</span> * @method getQueue
 * Get the current requests queue
 * @return {Array}
 */
exports.getQueue = function(){
	return queue;
};

<span id='HTTP-method-addToQueue'>/**
</span> * @method addToQueue
 * Add a request to queue
 * @param {HTTP.Request} request
 */
exports.addToQueue = function(request) {
	queue[request.hash] = request;
};

<span id='HTTP-method-removeFromQueue'>/**
</span> * @method removeFromQueue
 * Remove a request from queue
 */
exports.removeFromQueue = function(request) {
	delete queue[request.hash];
};


<span id='HTTP-method-resetCookies'>/**
</span> * @method resetCookies
 * Reset the cookies for all requests
 */
exports.resetCookies = function() {
	Ti.Network.createHTTPClient().clearCookies(exports.config.base);
};


<span id='HTTP-method-send'>/**
</span> * The main function of the module.
 *
 * Create an HTTP.Request and resolve it
 *
 * @param  {Object}	 opt 		The request dictionary
 * * * **url**: The endpoint URL
 * * **method**: The HTTP method to use (GET|POST|PUT|PATCH|..)
 * * **headers**: An Object key-value of additional headers
 * * **timeout**: Timeout after stopping the request and triggering an error
 * * **cache**: Set to false to disable the cache
 * * **success**: The success callback
 * * **error**: The error callback
 * * **format**: Override the format for that request (like `json`)
 * * **ttl**: Override the TTL seconds for the cache
 * @return {HTTP.Request}
 */
function send(opt) {
	var request = new (require(&#39;T/http/request&#39;))(opt);
	request.resolve();
	return request;
}
exports.send = send;


<span id='HTTP-method-get'>/**
</span> * @method get
 * Make a GET request to that URL
 * @param  {String}   	url The endpoint url
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error Error callback
 * @return {HTTP.Request}
 */
exports.get = function(url, success, error) {
	return send({
		url: url,
		method: &#39;GET&#39;,
		success: success,
		error: error
	});
};


<span id='HTTP-method-post'>/**
</span> * @method post
 * Make a POST request to that URL
 * @param  {String}   	url 		The endpoint url
 * @param  {Object}   	data 		The data
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error 	Error callback
 * @return {HTTP.Request}
 */
exports.post = function(url, data, success, error) {
	return send({
		url: url,
		method: &#39;POST&#39;,
		data: data,
		success: success,
		error: error
	});
};


<span id='HTTP-method-getJSON'>/**
</span> * @method  getJSON
 * Make a GET request to that url with that data and setting the format forced to JSON
 * @param  {String}   	url 		The endpoint url
 * @param  {Object}   	data 		The data
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error 	Error callback
 * @return {HTTP.Request}
 */
exports.getJSON = function(url, data, success, error) {
	return send({
		url: url,
		data: data,
		method: &#39;GET&#39;,
		format: &#39;json&#39;,
		success: success,
		error: error
	});
};


<span id='HTTP-method-postJSON'>/**
</span> * @method  postJSON
 * Make a POST request to that url with that data and setting the format forced to JSON
 * @param  {String}   	url 			The endpoint url
 * @param  {Object}   	data 			The data
 * @param  {Function} 	success  	Success callback
 * @param  {Function} 	error 		Error callback
 * @return {HTTP.Request}
 */
exports.postJSON = function(url, data, success, error) {
	return send({
		url: url,
		data: data,
		method: &#39;POST&#39;,
		format: &#39;json&#39;,
		success: success,
		error: error
	});
};


<span id='HTTP-method-download'>/**
</span> * @method download
 * @param  {String}  			url  				The url
 * @param  {Object}  			filename  		File name or `Ti.File`
 * @param  {Function}  			success  		Success callback
 * @param  {Function} 			error  			Error callback
 * @param  {Function}  			ondatastream  	Progress callback
 * @return {HTTP.Request}
 */
exports.download = function(url, file, success, error, ondatastream) {
	return send({
		url: url,
		cache: false,
		refresh: true,
		format: &#39;blob&#39;,
		error: error,
		ondatastream: ondatastream,
	}).success(function(data) {
		var fileStream = null;
		if (file.nativePath) {
			fileStream = file;
		} else {
			var APP_DATA_DIR = Util.getAppDataDirectory();
			Ti.Filesystem.getFile(APP_DATA_DIR).createDirectory();
			fileStream = Ti.Filesystem.getFile(APP_DATA_DIR, file);
		}

		if (fileStream.write(data)) {
			if (_.isFunction(success)) success(fileStream);
		} else {
			if (_.isFunction(error)) {
				error({
					message: L(&#39;unexpected_error&#39;, &#39;Unexpected error&#39;)
				});
			}
		}
	});
};

<span id='HTTP-method-exportCookiesToSystem'>/**
</span> * @method exportCookiesToSystem
 * Export the HTTP cookies to the system to make them available to `WebViews`
 * @param  {String} domain The domain. Default is `HTTP.config.base`
 */
exports.exportCookiesToSystem = function(domain) {
	if (!OS_ANDROID) return;

	domain = domain || HTTP.config.base.replace(&#39;http://&#39;, &#39;&#39;);
	_.each(Ti.Network.getHTTPCookiesForDomain(domain), function(c) {
		Ti.Network.addSystemCookie(c);
	});
};</pre>
</body>
</html>
