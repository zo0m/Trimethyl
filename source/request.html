<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='HTTP-Request'>/**
</span> * @class  	HTTP.Request
 * @author  Flavio De Stefano &lt;flavio.destefano@caffeinalab.com&gt;
 */

var HTTP = require(&#39;T/http&#39;);
var Util = require(&#39;T/util&#39;);
var Event = require(&#39;T/event&#39;);
var Cache = require(&#39;T/cache&#39;);
var Q = require(&#39;T/ext/q&#39;);

function extractHTTPText(data, info) {
	if (info != null &amp;&amp; data != null) {
		if (info.format === &#39;json&#39;) {
			return Util.parseJSON(data);
		}
	}
	return data;
}

function HTTPRequest(opt) {
	var self = this;
	if (opt.url == null) {
		throw new Error(&#39;HTTP.Request: URL not set&#39;);
	}

	this.opt = opt;

	// if the url is not matching a protocol, assign the base URL
	if (/\:\/\//.test(opt.url)) {
		this.url = opt.url;
	} else {
		this.url = HTTP.config.base.replace(/\/$/, &#39;&#39;) + &#39;/&#39; + opt.url.replace(/^\//, &#39;&#39;);
	}

	this.method = opt.method != null ? opt.method.toUpperCase() : &#39;GET&#39;;
	this.headers = _.extend({}, HTTP.getHeaders(), opt.headers);
	this.timeout = opt.timeout != null ? opt.timeout : HTTP.config.timeout;

	// Rebuild the URL if is a GET and there&#39;s data
	if (opt.data != null) {
		if (this.method === &#39;GET&#39; &amp;&amp; _.isObject(opt.data)) {
			var exQuery = /\?.*/.test(this.url);
			this.url = this.url + Util.buildQuery(opt.data, exQuery ? &#39;&amp;&#39; : &#39;?&#39;);
		} else {
			this.data = opt.data;
		}
	}

	this.hash = this._calculateHash();
	this.uniqueId = HTTP.getUniqueId();

	// Fill the defer, we will manage the callbacks through it
	this.defer = Q.defer();
	this.defer.promise.then(function() { self._onSuccess.apply(self, arguments); });
	this.defer.promise.fail(function() { self._onError.apply(self, arguments); });

	if (HTTP.config.log === true) {
		Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; created [&#39; + this.getDebugString() + &#39;]&#39;);
	}
}

HTTPRequest.prototype.toString = function() {
	return this.hash;
};

HTTPRequest.prototype.getDebugString = function() {
	return this.method + &#39; &#39; + this.url + (this.data ? &#39; &#39; + JSON.stringify(this.data) : &#39;&#39;);
};

HTTPRequest.prototype._maybeCacheResponse = function(data) {
	if (HTTP.config.useCache === false || this.opt.cache === false) return;
	if (this.method !== &#39;GET&#39;) return;

	if (this.responseInfo.ttl &lt;= 0) {
		if (HTTP.config.log === true) {
			Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; is uncachable due TTL &lt;= 0&#39;);
		}
		return;
	}

	Cache.set(this.hash, data, this.responseInfo.ttl, this.responseInfo);
	if (HTTP.config.log === true) {
		Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; has been cached successfully for &lt;&#39; + this.responseInfo.ttl + &#39;s&gt;&#39;);
	}
};


<span id='HTTP-Request-method-getCachedResponse'>/**
</span> * @method getCachedResponse
 * Return (if exists) the cache
 * @return {Object}
 */
HTTPRequest.prototype.getCachedResponse = function() {
	if (HTTP.config.useCache === false) return null;
	if (this.opt.cache === false || this.opt.refresh === true) return null;
	if (this.method !== &#39;GET&#39;) return null;

	var bypass = HTTP.config.bypassExpireWhenOffline &amp;&amp; !Ti.Network.online;
	var cachedData = Cache.get(this.hash, bypass);
	if (cachedData == null) return null;

	if (HTTP.config.log === true) {
		Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; cache hit up to &#39; + (cachedData.expire-Util.now()) + &#39;s&#39;);
	}

	if (cachedData.info.format === &#39;blob&#39;) {
		return cachedData.value;
	} else {
		return extractHTTPText(cachedData.value.text, cachedData.info);
	}
};

HTTPRequest.prototype._getResponseInfo = function() {
	if (this.client == null || this.client.readyState &lt;= 1) {
		return {
			broken: true
		};
	}

	var headers = {
		Expires: this.client.getResponseHeader(&#39;Expires&#39;),
		ContentType: this.client.getResponseHeader(&#39;Content-Type&#39;),
		TTL: this.client.getResponseHeader(&#39;X-Cache-Ttl&#39;)
	};

	var info = {
		format: &#39;blob&#39;,
		ttl: 0
	};

	if (this.client.responseText != null) {
		info.format = &#39;text&#39;;
		if (/application\/json/.test(headers.ContentType)) info.format = &#39;json&#39;;
	}

	// Always prefer X-Cache-Ttl over Expires
	if (headers.TTL != null) {
		info.ttl = headers.TTL;
	} else if (headers.Expires != null) {
		info.ttl = Util.timestamp(headers.Expires) - Util.now();
	}

	// Override
	if (this.opt.format != null) info.format = this.opt.format;
	if (this.opt.ttl != null) info.ttl = this.opt.ttl;

	return info;
};

HTTPRequest.prototype._onError = function(err) {
	var self = this;
	Ti.API.error(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt;&#39;, err);

	if (_.isFunction(this.opt.complete)) this.opt.complete(e);

	if (HTTP.config.errorAlert &amp;&amp; this.opt.errorAlert != false) {
		Util.errorAlert(err, function() {
			if (_.isFunction(self.opt.error)) self.opt.error(err);
		});
		return;
	}

	if (_.isFunction(self.opt.error)) self.opt.error(err);
};

HTTPRequest.prototype._onSuccess = function() {
	if (HTTP.config.logResponse === true) {
		Ti.API.trace(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt;&#39;, arguments[0]);
	}

	if (_.isFunction(this.opt.complete)) this.opt.complete.apply(this, arguments);
	if (_.isFunction(this.opt.success)) this.opt.success.apply(this, arguments);
};

HTTPRequest.prototype._onComplete = function(e) {
	this.endTime = Date.now();
	HTTP.removeFromQueue(this);

	// Fire the global event
	if (this.opt.silent != true) {
		Event.trigger(&#39;http.end&#39;, {
			hash: this.hash,
			eventName: this.opt.eventName
		});
	}

	this.responseInfo = this._getResponseInfo();

	// If the readyState is not DONE, trigger error, because
	// client.onload is the function to be called upon a SUCCESSFULL response.
	if (this.responseInfo.broken) {
		this.defer.reject({
			broken: true
		});
		return;
	}

	var data = null;
	if (this.opt.format === &#39;blob&#39;) {
		data = this.client.responseData;
	} else {
		data = extractHTTPText(this.client.responseText, this.responseInfo);
	}

	if (e.success) {
		if (HTTP.config.log === true) {
			Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; response success (in &#39; + (this.endTime-this.startTime) + &#39;ms)&#39;);
		}
		this._maybeCacheResponse(data);

		this.defer.resolve(data);

	} else {
		this.defer.reject({
			message: (this.opt.format === &#39;blob&#39;) ? null : Util.getErrorMessage(data),
			error: e.error,
			code: this.client.status,
			response: data
		});
	}

};

HTTPRequest.prototype._calculateHash = function() {
	var hash = this.url + Util.hashJavascriptObject(this.data) + Util.hashJavascriptObject(this.headers);
	return &#39;http_&#39; + Ti.Utils.md5HexDigest(hash);
};


<span id='HTTP-Request-method-send'>/**
</span> * @method send
 * Sent the request over the network
 */
HTTPRequest.prototype.send = function() {
	var self = this;

	this.client = Ti.Network.createHTTPClient({
		timeout: this.timeout,
		cache: false,
	});

	this.client.onload = this.client.onerror = function(e) { self._onComplete(e); };

	// Add this request to the queue
	HTTP.addToQueue(this);

	if (this.opt.silent != true) {
		Event.trigger(&#39;http.start&#39;, {
			hash: this.hash,
			eventName: this.opt.eventName
		});
	}

	// Progress callbacks
	if (_.isFunction(this.opt.ondatastream)) this.client.ondatastream = this.opt.ondatastream;
	if (_.isFunction(this.opt.ondatasend)) this.client.ondatasend = this.opt.ondatasend;

	// Set headers
	this.client.open(this.method, this.url);
	_.each(this.headers, function(h, k) {
		this.client.setRequestHeader(k, h);
	});

	// Send the request over Internet
	this.startTime = Date.now();
	if (this.data != null) {
		this.client.send(this.data);
	} else {
		this.client.send();
	}
};

<span id='HTTP-Request-method-resolve'>/**
</span> * @method resolve
 *
 * Magically resolve the request.
 * It checks cache, connectivity, and resolve.
 */
HTTPRequest.prototype.resolve = function() {
	var cache = this.getCachedResponse();
	if (cache != null) {
		this.defer.resolve(cache);
	} else {

		if (Ti.Network.online) {

			if (HTTP.config.log === true) {
				Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; sending request...&#39;);
			}
			this.send();

		} else {

			Event.trigger(&#39;http.offline&#39;);

			this.defer.reject({
				offline: true,
				message: L(&#39;network_offline&#39;, &#39;Check your connectivity.&#39;)
			});

		}
	}
};

<span id='HTTP-Request-method-abort'>/**
</span> * @method abort
 * Abort this request
 */
HTTPRequest.prototype.abort = function() {
	if (this.client != null) {
		this.client.abort();
		Ti.API.debug(&#39;HTTP: &lt;&#39; + this.uniqueId + &#39;&gt; aborted!&#39;);
	}
};


<span id='HTTP-Request-method-success'>/**
</span> * @method success
 * Promises, man!
 */
HTTPRequest.prototype.success = function(func) {
	this.defer.promise.then(func);
	return this;
};

<span id='HTTP-Request-method-error'>/**
</span> * @method error
 * Promises, man!
 */
HTTPRequest.prototype.error = function(func) {
	this.defer.promise.fail(func);
	return this;
};

<span id='HTTP-Request-method-error'>/**
</span> * @method error
 * Promises, man!
 */
HTTPRequest.prototype.complete = function(func) {
	this.defer.promise.fin(func);
	return this;
};

<span id='HTTP-Request-method-getPromise'>/**
</span> * @method getPromise
 * Get the deferred internal object
 */
HTTPRequest.prototype.getPromise = function() {
	return this.defer.promise;
};


module.exports = HTTPRequest;
</pre>
</body>
</html>
